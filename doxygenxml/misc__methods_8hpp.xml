<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="misc__methods_8hpp" kind="file" language="C++">
    <compoundname>misc_methods.hpp</compoundname>
    <includes local="no">cmath</includes>
    <includes local="no">queue</includes>
    <includes local="no">stdexcept</includes>
    <includes local="no">cassert</includes>
    <includes refid="Array2D_8hpp" local="yes">richdem/common/Array2D.hpp</includes>
    <includes refid="constants_8hpp" local="yes">richdem/common/constants.hpp</includes>
    <includes refid="ProgressBar_8hpp" local="yes">richdem/common/ProgressBar.hpp</includes>
    <incdepgraph>
      <node id="1038">
        <label>richdem/common/ProgressBar.hpp</label>
        <link refid="ProgressBar_8hpp"/>
        <childnode refid="1033" relation="include">
        </childnode>
        <childnode refid="1022" relation="include">
        </childnode>
        <childnode refid="1024" relation="include">
        </childnode>
        <childnode refid="1039" relation="include">
        </childnode>
        <childnode refid="1017" relation="include">
        </childnode>
        <childnode refid="1040" relation="include">
        </childnode>
      </node>
      <node id="1024">
        <label>iomanip</label>
      </node>
      <node id="1016">
        <label>queue</label>
      </node>
      <node id="1027">
        <label>limits</label>
      </node>
      <node id="1014">
        <label>/z/richdem/include/richdem/misc/misc_methods.hpp</label>
        <link refid="misc__methods_8hpp"/>
        <childnode refid="1015" relation="include">
        </childnode>
        <childnode refid="1016" relation="include">
        </childnode>
        <childnode refid="1017" relation="include">
        </childnode>
        <childnode refid="1018" relation="include">
        </childnode>
        <childnode refid="1019" relation="include">
        </childnode>
        <childnode refid="1035" relation="include">
        </childnode>
        <childnode refid="1038" relation="include">
        </childnode>
      </node>
      <node id="1015">
        <label>cmath</label>
      </node>
      <node id="1018">
        <label>cassert</label>
      </node>
      <node id="1017">
        <label>stdexcept</label>
      </node>
      <node id="1033">
        <label>string</label>
      </node>
      <node id="1019">
        <label>richdem/common/Array2D.hpp</label>
        <link refid="Array2D_8hpp"/>
        <childnode refid="1020" relation="include">
        </childnode>
        <childnode refid="1021" relation="include">
        </childnode>
        <childnode refid="1022" relation="include">
        </childnode>
        <childnode refid="1023" relation="include">
        </childnode>
        <childnode refid="1024" relation="include">
        </childnode>
        <childnode refid="1018" relation="include">
        </childnode>
        <childnode refid="1025" relation="include">
        </childnode>
        <childnode refid="1026" relation="include">
        </childnode>
        <childnode refid="1017" relation="include">
        </childnode>
        <childnode refid="1027" relation="include">
        </childnode>
        <childnode refid="1028" relation="include">
        </childnode>
        <childnode refid="1029" relation="include">
        </childnode>
        <childnode refid="1030" relation="include">
        </childnode>
        <childnode refid="1031" relation="include">
        </childnode>
        <childnode refid="1034" relation="include">
        </childnode>
        <childnode refid="1035" relation="include">
        </childnode>
        <childnode refid="1036" relation="include">
        </childnode>
      </node>
      <node id="1030">
        <label>map</label>
      </node>
      <node id="1029">
        <label>unordered_set</label>
      </node>
      <node id="1023">
        <label>fstream</label>
      </node>
      <node id="1026">
        <label>typeinfo</label>
      </node>
      <node id="1034">
        <label>richdem/common/version.hpp</label>
        <link refid="version_8hpp"/>
        <childnode refid="1033" relation="include">
        </childnode>
        <childnode refid="1022" relation="include">
        </childnode>
      </node>
      <node id="1028">
        <label>ctime</label>
      </node>
      <node id="1021">
        <label>vector</label>
      </node>
      <node id="1032">
        <label>sstream</label>
      </node>
      <node id="1039">
        <label>sys/time.h</label>
      </node>
      <node id="1022">
        <label>iostream</label>
      </node>
      <node id="1036">
        <label>richdem/common/ManagedVector.hpp</label>
        <link refid="ManagedVector_8hpp_source"/>
        <childnode refid="1037" relation="include">
        </childnode>
      </node>
      <node id="1020">
        <label>gdal.hpp</label>
        <link refid="gdal_8hpp_source"/>
      </node>
      <node id="1040">
        <label>richdem/common/timer.hpp</label>
        <link refid="timer_8hpp"/>
        <childnode refid="1039" relation="include">
        </childnode>
        <childnode refid="1017" relation="include">
        </childnode>
      </node>
      <node id="1035">
        <label>richdem/common/constants.hpp</label>
        <link refid="constants_8hpp"/>
      </node>
      <node id="1025">
        <label>algorithm</label>
      </node>
      <node id="1037">
        <label>memory</label>
      </node>
      <node id="1031">
        <label>richdem/common/logger.hpp</label>
        <link refid="logger_8hpp_source"/>
        <childnode refid="1022" relation="include">
        </childnode>
        <childnode refid="1032" relation="include">
        </childnode>
        <childnode refid="1033" relation="include">
        </childnode>
      </node>
    </incdepgraph>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="misc__methods_8hpp_1a6e62baeacdc52356332ff65bc9a0de81" prot="public" static="no">
        <name>PerimType</name>
        <enumvalue id="misc__methods_8hpp_1a6e62baeacdc52356332ff65bc9a0de81a2e4cd4081bcf8c4ed642cdd7b49bf806" prot="public">
          <name>CELL_COUNT</name>
          <briefdescription>
<para>Counts # of cells bordering DEM edges or NoData cells. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="misc__methods_8hpp_1a6e62baeacdc52356332ff65bc9a0de81acdf7e078d634e6847e3684fedb867eef" prot="public">
          <name>SQUARE_EDGE</name>
          <briefdescription>
<para>Adds all cell edges bordering DEM edges or NoData cells. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Calculates the perimeter of a digital elevation model. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="author"><para>Richard Barnes (<ulink url="mailto:rbarnes@umn.edu">rbarnes@umn.edu</ulink>)</para></simplesect>
Calculates the perimeter of a DEM in one of several ways: CELL_COUNT - # of cells bordering edges or NoData cells SQUARE_EDGE - Summation of all edges touch borders or NoData cells</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">&amp;arr</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The surface area of the digital elevation model </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/z/richdem/include/richdem/misc/misc_methods.hpp" line="193" column="1" bodyfile="/z/richdem/include/richdem/misc/misc_methods.hpp" bodystart="193" bodyend="196"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="misc__methods_8hpp_1aa445cdff66bec88df2fd03ad8b24c0e5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>double</type>
        <definition>double dem_surface_area</definition>
        <argsstring>(const Array2D&lt; T &gt; &amp;elevations, const double zscale)</argsstring>
        <name>dem_surface_area</name>
        <param>
          <type>const Array2D&lt; T &gt; &amp;</type>
          <declname>elevations</declname>
        </param>
        <param>
          <type>const double</type>
          <declname>zscale</declname>
        </param>
        <briefdescription>
<para>Calculate the surface of a digital elevation model. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="author"><para>Jenness (2004), Richard Barnes (<ulink url="mailto:rbarnes@umn.edu">rbarnes@umn.edu</ulink>)</para></simplesect>
Calculates the surface area of a digital elevation model by connecting the central points of cells with triangles and then calculating the area of the portion of each triangle which falls within the focal cell. The method is described in detail in Jenness (2004) &lt;doi:10.2193/0091-7648(2004)032[0829:CLSAFD]2.0.CO;2&gt;</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">&amp;elevations</parametername>
</parameternamelist>
<parameterdescription>
<para>A grid of elevations </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">zscale</parametername>
</parameternamelist>
<parameterdescription>
<para>DEM is scaled by this factor prior to calculation</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The surface area of the digital elevation model </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/z/richdem/include/richdem/misc/misc_methods.hpp" line="38" column="1" bodyfile="/z/richdem/include/richdem/misc/misc_methods.hpp" bodystart="38" bodyend="167"/>
      </memberdef>
      <memberdef kind="function" id="misc__methods_8hpp_1a9fffb65809435703b51ec80d09fa6fd1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>double</type>
        <definition>double Perimeter</definition>
        <argsstring>(const Array2D&lt; T &gt; &amp;arr, const PerimType perim_type)</argsstring>
        <name>Perimeter</name>
        <param>
          <type>const Array2D&lt; T &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const <ref refid="misc__methods_8hpp_1a6e62baeacdc52356332ff65bc9a0de81" kindref="member">PerimType</ref></type>
          <declname>perim_type</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/z/richdem/include/richdem/misc/misc_methods.hpp" line="199" column="1" bodyfile="/z/richdem/include/richdem/misc/misc_methods.hpp" bodystart="199" bodyend="250"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Terrain attributes that can only be calculated with Tarboton&apos;s D-infinity flow metric. </para>    </briefdescription>
    <detaileddescription>
<para><simplesect kind="author"><para>Richard Barnes (<ulink url="mailto:rbarnes@umn.edu">rbarnes@umn.edu</ulink>), 2015</para></simplesect>
This file implements the D-infinite flow routing method originally described by Tarboton (1997). It incorporates minor alterations and additional safe-guards described in Barnes (2013, TODO). </para>    </detaileddescription>
    <programlisting>
<codeline lineno="1"></codeline>
<codeline lineno="10"><highlight class="preprocessor">#ifndef<sp/>_richdem_dinf_methods_hpp_</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>_richdem_dinf_methods_hpp_</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12"><highlight class="normal"></highlight></codeline>
<codeline lineno="13"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cmath&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;queue&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdexcept&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="Array2D_8hpp" kindref="compound">richdem/common/Array2D.hpp</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="18"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="constants_8hpp" kindref="compound">richdem/common/constants.hpp</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="19"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="ProgressBar_8hpp" kindref="compound">richdem/common/ProgressBar.hpp</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="20"><highlight class="normal"></highlight></codeline>
<codeline lineno="21"><highlight class="normal"></highlight></codeline>
<codeline lineno="37"><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="38" refid="misc__methods_8hpp_1aa445cdff66bec88df2fd03ad8b24c0e5" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/><ref refid="misc__methods_8hpp_1aa445cdff66bec88df2fd03ad8b24c0e5" kindref="member">dem_surface_area</ref>(</highlight></codeline>
<codeline lineno="39"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Array2D&lt;T&gt;<sp/>&amp;elevations,</highlight></codeline>
<codeline lineno="40"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>zscale</highlight></codeline>
<codeline lineno="41"><highlight class="normal">){</highlight></codeline>
<codeline lineno="42"><highlight class="normal"><sp/><sp/>ProgressBar<sp/>progress;</highlight></codeline>
<codeline lineno="43"><highlight class="normal"></highlight></codeline>
<codeline lineno="44"><highlight class="normal"><sp/><sp/>std::cerr&lt;&lt;</highlight><highlight class="stringliteral">&quot;\nA<sp/>DEM<sp/>Surface<sp/>Elevation&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline lineno="45"><highlight class="normal"><sp/><sp/>std::cerr&lt;&lt;</highlight><highlight class="stringliteral">&quot;C<sp/>Jenness,<sp/>J.S.,<sp/>2004.<sp/>Calculating<sp/>landscape<sp/>surface<sp/>area<sp/>from<sp/>digital<sp/>elevation<sp/>models.<sp/>Wildlife<sp/>Society<sp/>Bulletin<sp/>32,<sp/>829--839.<sp/>doi:10.2193/0091-7648(2004)032[0829:CLSAFD]2.0.CO;2&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline lineno="46"><highlight class="normal"></highlight></codeline>
<codeline lineno="47"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>euc_dist<sp/>=<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>a,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>b){<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>std::sqrt(std::pow((</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">)a,2.0)+std::pow((</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">)b,2.0));<sp/>};</highlight></codeline>
<codeline lineno="48"><highlight class="normal"></highlight></codeline>
<codeline lineno="49"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//If<sp/>calculate<sp/>cell<sp/>area<sp/>is<sp/>lower<sp/>than<sp/>actual<sp/>area,<sp/>but<sp/>greater<sp/>than<sp/>&quot;AA<sp/>minus</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="50"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//fudge_factor&quot;,<sp/>we<sp/>clamp<sp/>the<sp/>calculated<sp/>area<sp/>to<sp/>the<sp/>actual<sp/>area<sp/>without</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="51"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//raising<sp/>an<sp/>error.<sp/>If<sp/>the<sp/>calculated<sp/>area<sp/>is<sp/>lower<sp/>than<sp/>the<sp/>fudge_factor,<sp/>we</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="52"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//raise<sp/>an<sp/>alarm.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="53"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>fudge_factor<sp/>=<sp/>1e-4;<sp/></highlight></codeline>
<codeline lineno="54"><highlight class="normal"></highlight></codeline>
<codeline lineno="55"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//Using<sp/>double<sp/>as<sp/>an<sp/>accumulator<sp/>here<sp/>is<sp/>important!<sp/>Testing<sp/>this<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="56"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//using<sp/>the<sp/>Boost<sp/>Numeric<sp/>Interval<sp/>library<sp/>should<sp/>data<sp/>such<sp/>as<sp/>follows:</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="57"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//Single-precision<sp/>sum<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>2.14851e+09</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="58"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//Double-precision<sp/>sum<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>1.61629e+10</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="59"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//Single-precision<sp/>interval<sp/>Width<sp/>=<sp/>1.09655e+14</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="60"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//Single-precision<sp/>interval<sp/>Lower<sp/>=<sp/>1.07436e+09</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="61"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//Single-precision<sp/>interval<sp/>Upper<sp/>=<sp/>1.09656e+14</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="62"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//Double-precision<sp/>interval<sp/>Width<sp/>=<sp/>181.906</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="63"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//Double-precision<sp/>interval<sp/>Lower<sp/>=<sp/>1.61629e+10</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="64"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//Double-precision<sp/>interval<sp/>Upper<sp/>=<sp/>1.61629e+10</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="65"><highlight class="normal"></highlight></codeline>
<codeline lineno="66"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//The<sp/>upshot<sp/>is<sp/>that<sp/>there<sp/>is<sp/>significant<sp/>uncertainty<sp/>associated<sp/>with<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="67"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//floating-point<sp/>accumulator<sp/>while<sp/>the<sp/>double<sp/>accumulator<sp/>has<sp/>negligible</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="68"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//uncertainty.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="69"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>area<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="70"><highlight class="normal"></highlight></codeline>
<codeline lineno="71"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>xdist<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>elevations.getCellLengthX();</highlight></codeline>
<codeline lineno="72"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>ydist<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>elevations.getCellLengthY();</highlight></codeline>
<codeline lineno="73"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>planar_diag_dist<sp/>=<sp/>euc_dist(xdist,ydist);</highlight></codeline>
<codeline lineno="74"><highlight class="normal"></highlight></codeline>
<codeline lineno="75"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//TODO:<sp/>This<sp/>algorithm<sp/>would<sp/>benefit<sp/>from<sp/>GPU<sp/>integration</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="76"><highlight class="normal"><sp/><sp/>progress.start(elevations.size());</highlight></codeline>
<codeline lineno="77"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/>#pragma<sp/>omp<sp/>parallel<sp/>for<sp/>reduction(+:area)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="78"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>y=0;y&lt;elevations.height();y++){</highlight></codeline>
<codeline lineno="79"><highlight class="normal"><sp/><sp/><sp/><sp/>progress.update(<sp/>y*elevations.width()<sp/>);</highlight></codeline>
<codeline lineno="80"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>x=0;x&lt;elevations.width();x++){</highlight></codeline>
<codeline lineno="81"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(elevations.isNoData(x,y))</highlight></codeline>
<codeline lineno="82"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="83"><highlight class="normal"></highlight></codeline>
<codeline lineno="84"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//We<sp/>sum<sp/>into<sp/>`cell_area`<sp/>rather<sp/>than<sp/>`area`<sp/>so<sp/>that<sp/>our<sp/>values<sp/>are<sp/>larger</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="85"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//when<sp/>we<sp/>add<sp/>to<sp/>`area`.<sp/>This<sp/>helps<sp/>prevent<sp/>small<sp/>numbers<sp/>from<sp/>being</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="86"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//&quot;swallowed&quot;<sp/>by<sp/>large<sp/>numbers,<sp/>and<sp/>other<sp/>floating-point<sp/>stuff.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="87"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>cell_area<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="88"><highlight class="normal"></highlight></codeline>
<codeline lineno="89"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Loop<sp/>through<sp/>neighbours</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="90"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n=1;n&lt;=8;n++){</highlight></codeline>
<codeline lineno="91"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//This<sp/>is<sp/>the<sp/>next<sp/>neighbour,<sp/>which<sp/>forms<sp/>part<sp/>of<sp/>the<sp/>triangle</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="92"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nn<sp/>=<sp/>n+1;</highlight></codeline>
<codeline lineno="93"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(nn==9)<sp/></highlight><highlight class="comment">//Wrap<sp/>around</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="94"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nn<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="95"><highlight class="normal"></highlight></codeline>
<codeline lineno="96"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//In<sp/>each<sp/>triangle<sp/>one<sp/>neighbour<sp/>is<sp/>in<sp/>the<sp/>diagonal<sp/>direction<sp/>and<sp/>one<sp/>is</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="97"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//in<sp/>a<sp/>straight<sp/>direction.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="98"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>dn<sp/><sp/>=<sp/>n;<sp/><sp/><sp/></highlight><highlight class="comment">//Diagonal<sp/>Neighbour</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="99"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ndn<sp/>=<sp/>nn;<sp/><sp/></highlight><highlight class="comment">//Not-diagonal<sp/>neighbour</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="100"><highlight class="normal"></highlight></codeline>
<codeline lineno="101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//As<sp/>we<sp/>walk<sp/>around<sp/>half<sp/>of<sp/>the<sp/>time<sp/>we&apos;ll<sp/>misidentify<sp/>the<sp/>diagonal</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="102"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//neighbour,<sp/>but<sp/>we<sp/>can<sp/>fix<sp/>that<sp/>here<sp/>by<sp/>swapping<sp/>the<sp/>labels<sp/>we<sp/>just</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//gave<sp/>the<sp/>neighbours</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!n_diag[dn])</highlight></codeline>
<codeline lineno="105"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::swap(dn,ndn);</highlight></codeline>
<codeline lineno="106"><highlight class="normal"></highlight></codeline>
<codeline lineno="107"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>my_elev<sp/>=<sp/>zscale*elevations(x,y);</highlight></codeline>
<codeline lineno="108"><highlight class="normal"></highlight></codeline>
<codeline lineno="109"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Deal<sp/>with<sp/>the<sp/>possibility<sp/>that<sp/>the<sp/>neighbouring<sp/>cells<sp/>do<sp/>not<sp/>exist.<sp/>In</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="110"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//this<sp/>case,<sp/>we<sp/>pretend<sp/>that<sp/>they<sp/>do<sp/>exist<sp/>and<sp/>are<sp/>at<sp/>the<sp/>same<sp/>height<sp/>as</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="111"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//the<sp/>focal<sp/>cell.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="112"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>dn_elev;</highlight></codeline>
<codeline lineno="113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(elevations.inGrid(x+dx[dn],y+dy[dn])<sp/>&amp;&amp;<sp/>!elevations.isNoData(x+dx[dn],y+dy[dn]))</highlight></codeline>
<codeline lineno="114"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dn_elev<sp/>=<sp/>zscale*elevations(x+dx[dn],y+dy[dn]);</highlight></codeline>
<codeline lineno="115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dn_elev<sp/>=<sp/>my_elev;</highlight></codeline>
<codeline lineno="117"><highlight class="normal"></highlight></codeline>
<codeline lineno="118"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Do<sp/>the<sp/>same<sp/>for<sp/>the<sp/>other<sp/>neighbour</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="119"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>ndn_elev;</highlight></codeline>
<codeline lineno="120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(elevations.inGrid(x+dx[ndn],y+dy[ndn])<sp/>&amp;&amp;<sp/>!elevations.isNoData(x+dx[ndn],y+dy[ndn]))</highlight></codeline>
<codeline lineno="121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ndn_elev<sp/>=<sp/>zscale*elevations(x+dx[ndn],y+dy[ndn]);</highlight></codeline>
<codeline lineno="122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ndn_elev<sp/>=<sp/>my_elev;</highlight></codeline>
<codeline lineno="124"><highlight class="normal"><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>planar_dist_dn<sp/><sp/><sp/>=<sp/>planar_diag_dist;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Distance<sp/>focal<sp/>cell<sp/>to<sp/>diagonal<sp/>neighbour</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>planar_dist_ndn<sp/><sp/>=<sp/>(dy[ndn]<sp/>==<sp/>0)?xdist:ydist;<sp/><sp/></highlight><highlight class="comment">//Distance<sp/>focal<sp/>cell<sp/>to<sp/>non-diagonal<sp/>neighbour</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>planar_dist_bn<sp/><sp/><sp/>=<sp/>(dy[ndn]<sp/>==<sp/>0)?ydist:xdist;<sp/><sp/></highlight><highlight class="comment">//Distance<sp/>between<sp/>the<sp/>neighbour<sp/>cells</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="128"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>elev_diff_dn<sp/><sp/><sp/><sp/><sp/>=<sp/>dn_elev<sp/>-my_elev;<sp/></highlight><highlight class="comment">//Elevation<sp/>drop<sp/>between<sp/>focal<sp/>and<sp/>diagonal</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>elev_diff_ndn<sp/><sp/><sp/><sp/>=<sp/>ndn_elev-my_elev;<sp/></highlight><highlight class="comment">//Elevation<sp/>drop<sp/>between<sp/>focal<sp/>and<sp/>non-diagonal</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>elev_diff_bn<sp/><sp/><sp/><sp/><sp/>=<sp/>ndn_elev-dn_elev;<sp/></highlight><highlight class="comment">//Elevation<sp/>drop<sp/>between<sp/>neighbours</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="132"><highlight class="normal"></highlight></codeline>
<codeline lineno="133"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Divide<sp/>these<sp/>distances<sp/>by<sp/>two<sp/>to<sp/>form<sp/>a<sp/>similar<sp/>triangle<sp/>constrained</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="134"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//by<sp/>the<sp/>boundary<sp/>of<sp/>the<sp/>focal<sp/>cell</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="135"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>surf_dist_dn<sp/><sp/><sp/><sp/><sp/>=<sp/>euc_dist(planar_dist_dn,elev_diff_dn)/2;<sp/><sp/><sp/></highlight><highlight class="comment">//3-space<sp/>distance<sp/>between<sp/>center<sp/>of<sp/>focal<sp/>and<sp/>diagonal<sp/>neighbour</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>surf_dist_ndn<sp/><sp/><sp/><sp/>=<sp/>euc_dist(planar_dist_ndn,elev_diff_ndn)/2;<sp/></highlight><highlight class="comment">//3-space<sp/>distance<sp/>between<sp/>center<sp/>of<sp/>focal<sp/>and<sp/>non-diagonal<sp/>neighbour</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="137"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>surf_dist_bn<sp/><sp/><sp/><sp/><sp/>=<sp/>euc_dist(planar_dist_bn,elev_diff_bn)/2;<sp/><sp/><sp/></highlight><highlight class="comment">//3-space<sp/>distance<sp/>between<sp/>neighbours</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="138"><highlight class="normal"></highlight></codeline>
<codeline lineno="139"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Used<sp/>to<sp/>get<sp/>area<sp/>of<sp/>triangle</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="140"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>s<sp/>=<sp/>(surf_dist_dn+surf_dist_ndn+surf_dist_bn)/2;</highlight></codeline>
<codeline lineno="141"><highlight class="normal"></highlight></codeline>
<codeline lineno="142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Accumulate<sp/>area<sp/>of<sp/>triangle<sp/>to</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="143"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>tri_area<sp/>=<sp/>std::sqrt(s*(s-surf_dist_dn)*(s-surf_dist_ndn)*(s-surf_dist_bn));</highlight></codeline>
<codeline lineno="144"><highlight class="normal"></highlight></codeline>
<codeline lineno="145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cell_area<sp/>+=<sp/>tri_area;</highlight></codeline>
<codeline lineno="146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="147"><highlight class="normal"></highlight></codeline>
<codeline lineno="148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(cell_area&lt;elevations.getCellArea()){</highlight></codeline>
<codeline lineno="149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(cell_area+fudge_factor&gt;=elevations.getCellArea())</highlight></codeline>
<codeline lineno="150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cell_area<sp/>=<sp/>elevations.getCellArea();</highlight></codeline>
<codeline lineno="151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">throw</highlight><highlight class="normal"><sp/>std::runtime_error(</highlight><highlight class="stringliteral">&quot;A<sp/>cell<sp/>had<sp/>a<sp/>topographic<sp/>surface<sp/>area<sp/>less<sp/>than<sp/>its<sp/>planar<sp/>surface<sp/>area!&quot;</highlight><highlight class="normal">);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="154"><highlight class="normal"></highlight></codeline>
<codeline lineno="155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>area<sp/>+=<sp/>cell_area;</highlight></codeline>
<codeline lineno="156"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="157"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/>std::cerr&lt;&lt;</highlight><highlight class="stringliteral">&quot;p<sp/>Succeeded<sp/>in<sp/>=<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;progress.stop()&lt;&lt;</highlight><highlight class="stringliteral">&quot;<sp/>s&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline lineno="159"><highlight class="normal"></highlight></codeline>
<codeline lineno="160"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>dem_planar_area<sp/>=<sp/>elevations.numDataCells()*elevations.getCellArea();</highlight></codeline>
<codeline lineno="161"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(area&lt;dem_planar_area){</highlight></codeline>
<codeline lineno="162"><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr&lt;&lt;</highlight><highlight class="stringliteral">&quot;W<sp/>Topographic<sp/>surface<sp/>area<sp/>(&quot;</highlight><highlight class="normal">+std::to_string(area)+</highlight><highlight class="stringliteral">&quot;)<sp/>&lt;<sp/>planar<sp/>surface<sp/>area<sp/>(&quot;</highlight><highlight class="normal">+std::to_string(dem_planar_area)<sp/>+</highlight><highlight class="stringliteral">&quot;)!<sp/>Choosing<sp/>planar<sp/>area.&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="163"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>dem_planar_area;</highlight></codeline>
<codeline lineno="164"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="165"><highlight class="normal"></highlight></codeline>
<codeline lineno="166"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>area;</highlight></codeline>
<codeline lineno="167"><highlight class="normal">}</highlight></codeline>
<codeline lineno="168"><highlight class="normal"></highlight></codeline>
<codeline lineno="169"><highlight class="normal"></highlight></codeline>
<codeline lineno="170"><highlight class="normal"></highlight></codeline>
<codeline lineno="171"><highlight class="normal"></highlight></codeline>
<codeline lineno="172"><highlight class="normal"></highlight></codeline>
<codeline lineno="173"><highlight class="normal"></highlight></codeline>
<codeline lineno="174"><highlight class="normal"></highlight></codeline>
<codeline lineno="175"><highlight class="normal"></highlight></codeline>
<codeline lineno="176"><highlight class="normal"></highlight></codeline>
<codeline lineno="177"><highlight class="normal"></highlight></codeline>
<codeline lineno="178"><highlight class="normal"></highlight></codeline>
<codeline lineno="179"><highlight class="normal"></highlight></codeline>
<codeline lineno="180"><highlight class="normal"></highlight></codeline>
<codeline lineno="193" refid="misc__methods_8hpp_1a6e62baeacdc52356332ff65bc9a0de81" refkind="member"><highlight class="keyword">enum<sp/>class</highlight><highlight class="normal"><sp/><ref refid="misc__methods_8hpp_1a6e62baeacdc52356332ff65bc9a0de81" kindref="member">PerimType</ref><sp/>{</highlight></codeline>
<codeline lineno="194"><highlight class="normal"><sp/><sp/><ref refid="misc__methods_8hpp_1a6e62baeacdc52356332ff65bc9a0de81a2e4cd4081bcf8c4ed642cdd7b49bf806" kindref="member">CELL_COUNT</ref>,<sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/><ref refid="misc__methods_8hpp_1a6e62baeacdc52356332ff65bc9a0de81acdf7e078d634e6847e3684fedb867eef" kindref="member">SQUARE_EDGE</ref>,<sp/><sp/><sp/></highlight></codeline>
<codeline lineno="196"><highlight class="normal">};</highlight></codeline>
<codeline lineno="197"><highlight class="normal"></highlight></codeline>
<codeline lineno="198"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="199"><highlight class="normal"></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>Perimeter(</highlight></codeline>
<codeline lineno="200"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Array2D&lt;T&gt;<sp/>&amp;arr,</highlight></codeline>
<codeline lineno="201"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="misc__methods_8hpp_1a6e62baeacdc52356332ff65bc9a0de81" kindref="member">PerimType</ref><sp/>perim_type</highlight></codeline>
<codeline lineno="202"><highlight class="normal">){</highlight></codeline>
<codeline lineno="203"><highlight class="normal"><sp/><sp/>ProgressBar<sp/>progress;</highlight></codeline>
<codeline lineno="204"><highlight class="normal"></highlight></codeline>
<codeline lineno="205"><highlight class="normal"><sp/><sp/>std::cerr&lt;&lt;</highlight><highlight class="stringliteral">&quot;\nA<sp/>DEM<sp/>Perimeter&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline lineno="206"><highlight class="normal"><sp/><sp/>std::cerr&lt;&lt;</highlight><highlight class="stringliteral">&quot;C<sp/>TODO&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline lineno="207"><highlight class="normal"></highlight></codeline>
<codeline lineno="208"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>vertical_edges<sp/><sp/><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="209"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>horizontal_edges<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="210"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>cell_edges<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="211"><highlight class="normal"></highlight></codeline>
<codeline lineno="212"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//TODO:<sp/>This<sp/>algorithm<sp/>would<sp/>benefit<sp/>from<sp/>GPU<sp/>integration</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="213"><highlight class="normal"><sp/><sp/>progress.start(arr.size());</highlight></codeline>
<codeline lineno="214"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/>#pragma<sp/>omp<sp/>parallel<sp/>for<sp/>reduction(+:cell_edges)<sp/>reduction(+:vertical_edges)<sp/>reduction(+:horizontal_edges)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="215"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>y=0;y&lt;arr.height();y++){</highlight></codeline>
<codeline lineno="216"><highlight class="normal"><sp/><sp/><sp/><sp/>progress.update(<sp/>y*arr.width()<sp/>);</highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>x=0;x&lt;arr.width();x++){</highlight></codeline>
<codeline lineno="218"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(arr.isNoData(x,y))</highlight></codeline>
<codeline lineno="219"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="220"><highlight class="normal"></highlight></codeline>
<codeline lineno="221"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(perim_type==<ref refid="misc__methods_8hpp_1a6e62baeacdc52356332ff65bc9a0de81a2e4cd4081bcf8c4ed642cdd7b49bf806" kindref="member">PerimType::CELL_COUNT</ref>){</highlight></codeline>
<codeline lineno="222"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n=1;n&lt;=8;n++){</highlight></codeline>
<codeline lineno="223"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!arr.inGrid(x+dx[n],y+dy[n])){</highlight></codeline>
<codeline lineno="224"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cell_edges++;</highlight></codeline>
<codeline lineno="225"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="226"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="227"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="228"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(perim_type==<ref refid="misc__methods_8hpp_1a6e62baeacdc52356332ff65bc9a0de81acdf7e078d634e6847e3684fedb867eef" kindref="member">PerimType::SQUARE_EDGE</ref>){</highlight></codeline>
<codeline lineno="229"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n=1;n&lt;=8;n++){</highlight></codeline>
<codeline lineno="230"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!arr.inGrid(x+dx[n],y+dy[n])<sp/>||<sp/>arr.isNoData(x+dx[n],y+dy[n])){</highlight></codeline>
<codeline lineno="231"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(dx[n]==0)<sp/></highlight><highlight class="comment">//Pointing<sp/>at<sp/>a<sp/>cell<sp/>above<sp/>or<sp/>below,<sp/>so<sp/>horizontal<sp/>edge</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="232"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>horizontal_edges++;</highlight></codeline>
<codeline lineno="233"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(dy[n]==0)<sp/></highlight><highlight class="comment">//Point<sp/>at<sp/>cell<sp/>left<sp/>or<sp/>right,<sp/>so<sp/>vertical<sp/>edge</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="234"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vertical_edges++;</highlight></codeline>
<codeline lineno="235"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="236"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="237"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="238"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">throw</highlight><highlight class="normal"><sp/>std::runtime_error(</highlight><highlight class="stringliteral">&quot;Unrecognised<sp/>PerimType!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="239"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="240"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="241"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="242"><highlight class="normal"><sp/><sp/>std::cerr&lt;&lt;</highlight><highlight class="stringliteral">&quot;p<sp/>Succeeded<sp/>in<sp/>=<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;progress.stop()&lt;&lt;</highlight><highlight class="stringliteral">&quot;<sp/>s&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline lineno="243"><highlight class="normal"></highlight></codeline>
<codeline lineno="244"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(perim_type==<ref refid="misc__methods_8hpp_1a6e62baeacdc52356332ff65bc9a0de81a2e4cd4081bcf8c4ed642cdd7b49bf806" kindref="member">PerimType::CELL_COUNT</ref>)</highlight></codeline>
<codeline lineno="245"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cell_edges;</highlight></codeline>
<codeline lineno="246"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(perim_type==<ref refid="misc__methods_8hpp_1a6e62baeacdc52356332ff65bc9a0de81acdf7e078d634e6847e3684fedb867eef" kindref="member">PerimType::SQUARE_EDGE</ref>)</highlight></codeline>
<codeline lineno="247"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>horizontal_edges*arr.getCellLengthX()+vertical_edges*arr.getCellLengthY();</highlight></codeline>
<codeline lineno="248"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="249"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">throw</highlight><highlight class="normal"><sp/>std::runtime_error(</highlight><highlight class="stringliteral">&quot;Unrecognised<sp/>PerimType!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="250"><highlight class="normal">}</highlight></codeline>
<codeline lineno="251"><highlight class="normal"></highlight></codeline>
<codeline lineno="252"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
    </programlisting>
    <location file="/z/richdem/include/richdem/misc/misc_methods.hpp"/>
  </compounddef>
</doxygen>
