<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="md__z_richdem_include_richdem_depressions_README" kind="page">
    <compoundname>md__z_richdem_include_richdem_depressions_README</compoundname>
    <title>Barnes2013-Depressions</title>
    <detaileddescription>
<para><bold>Title of Manuscript</bold>: Priority-Flood: An Optimal Depression-Filling and Watershed-Labeling Algorithm for Digital Elevation Models</para><para><bold>Authors</bold>: Richard Barnes, Clarence Lehman, David Mulla</para><para><bold>Corresponding Author</bold>: Richard Barnes (<ulink url="mailto:rbarnes@umn.edu">rbarnes@umn.edu</ulink>)</para><para><bold>DOI Number of Manuscript</bold> <ulink url="http://dx.doi.org/10.1016/j.cageo.2013.04.024">10.1016/j.cageo.2013.04.024</ulink></para><para><bold>Code Repositories</bold><itemizedlist>
<listitem><para><ulink url="https://github.com/r-barnes/Barnes2013-Depressions">Author&apos;s GitHub Repository</ulink></para></listitem><listitem><para><ulink url="https://github.com/cageo">Journal&apos;s GitHub Repository</ulink></para></listitem></itemizedlist>
</para><para>This repository contains a reference implementation of the algorithms presented in the manuscript above. These implementations were used in performing the tests described in the manuscript.</para><para>There is source code for every pseudocode algorithm presented in the manuscript. All the code can be compiled simply by running <bold>make</bold>. The result is a program called <bold>priority_flood.exe</bold>.</para><para>This program reads in a DEM file specified on the command line. The file may be any ArcGrid ASCII file. The program will run one of the algorithms described in the manuscript (and below), store the result in an output file, and report how long this took.</para><para>The program is run by typing: <verbatim>./priority_flood.exe &lt;ALGORITHM NUMBER&gt; &lt;INPUT DEM&gt;
./priority_flood.exe 3 input-data.asc
</verbatim></para><para>The algorithms available are described briefly below and in greater detail in the manuscript.</para><para><itemizedlist>
<listitem><para><bold>Algorithm 1: Priority-Flood</bold> This algorithm alters the input DEM to produce an output with no depressions or digital dams. Every cell which would have been in a depression is increased to the level of that depression&apos;s outlet, leaving a flat region in its place. It runs slower than Algorithm 2, but is otherwise the same. The result is saved to <bold>out-pf-original</bold>.</para></listitem><listitem><para><bold>Algorithm 2: Improved Priority-Flood</bold> This algorithm alters the input DEM to produce an output with no depressions or digital dams. Every cell which would have been in a depression is increased to the level of that depression&apos;s outlet, leaving a flat region in its place. It runs faster than Algorithm 1, but is otherwise the same. The result is saved to <bold>out-pf-improved</bold>.</para></listitem><listitem><para><bold>Algorithm 3: Priority-Flood+Epsilon</bold> This algorithm alters the input DEM to produce an output with no depressions or digital dams. Every cell which would have been in a depression is increased to the level of that depression&apos;s output, plus an additional increment which is sufficient to direct flow to the periphery of the DEM. The result is saved to <bold>out-pf-epsilon</bold>.</para></listitem><listitem><para><bold>Algorithm 4: Priority-Flood+FlowDirs</bold> This algorithm determines a D8 flow direction for every cell in the DEM by implicitly filling depressions and eliminating digital dams. Though all depressions are guaranteed to drain, local elevation information is still used to determine flow directions within a depression. It is, in essence, a depression-carving algorithm. The result is saved to <bold>out-pf-flowdirs</bold>.</para></listitem><listitem><para><bold>Algorithm 5: Priority-Flood+Watershed Labels</bold> For each cell <emphasis>c</emphasis> in a DEM, this algorithm determines which cell on the DEM&apos;s periphery <emphasis>c</emphasis> will drain to. <emphasis>c</emphasis> is then given a label which corresponds to the peripheral cell. All cells bearing a common label belong to the same watershed. The result is saved to <bold>out-pf-wlabels</bold>.</para></listitem></itemizedlist>
</para><para><bold>Algorithm 4: Priority-Flood+FlowDirs</bold> and its output, <bold>out-pf-flowdirs</bold>, use the D8 neighbour system to indicate flow directions. In this system all the flow from a central cell is directed to a single neighbour which is represented by a number according to the following system where 0 indicates the central cell. <verbatim>234
105
876
</verbatim></para><para>The directory <bold>src/</bold> contains the source code for the reference implementations. All the source code is drawn from the RichDEM hydroanalysis package. At the time of writing, the entire RichDEM code base could be downloaded from: <ulink url="https://github.com/r-barnes">https://github.com/r-barnes</ulink></para><para><heading level="1">Assumptions </heading>
</para><para>All of the algorithms assume that cells marked as having NoData will have extremely negative numerical values: less than the value of any of the actual data. NaN is considered to be less than all values, including negative infinity.</para><para><heading level="1">Notes on the Manuscript </heading>
</para><para>Work by Cris Luengo on the speed of various priority queue algorithms is discussed in the manuscript. His website providing code for his implementatations is <ulink url="http://www.cb.uu.se/~cris/priorityqueues.html">here</ulink>.</para><para><heading level="1">Updates </heading>
</para><para>Commit <bold>51f9a7838d3e88628ef6c74846edd0cb18e7ffe6</bold> (02015-09-25) introduced a number of changes to the code versus what was originally published with the manuscript. The old codebase uses ASCII-formatted data for input and output; the new codebase uses GDAL to handle many kinds of data.</para><para>The old codebase had the advantage of not relying on external libraries and being readily accessible to all parties. It had the disadvantage of being a slow, clumsy, and limited way to work with the data. As of 02015-09-25, the code requires the use of the GDAL library greatly expanding the data formats and data types which can be worked with, as well as greatly speeding up I/O.</para><para>Note that using the aforementioned <bold>51f9a7838d</bold> directly will result in silent casting of your data to the <computeroutput>float</computeroutput> type; commit <bold>8b11f535af23368d3bd26609cc88df3dbb7111f1</bold> (02015-09-28) fixes this issue.</para><para>Additionally, the library now uses C++ for all streaming operations except the progress bar. </para>    </detaileddescription>
  </compounddef>
</doxygen>
